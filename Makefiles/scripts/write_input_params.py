#!/usr/bin/env python
#
# Script to generate a module that takes care of runtime parameters
# for Fortran programs. This parses an input file with variable names, 
# variable types and default values and writes the fortran module using 
# a template.
#
# Original Idea borrowed from the MAESTRO code
#
# This code is based off of BoxLib routines
#
# 2013-04-05 R. Orvedahl
#

from __future__ import print_function
import sys
import getopt

Header ="""
! DO NOT EDIT THIS FILE!!!!
!
! This file is automatically generated by write_input_params.py at
! compile time.
!
! To add a runtime parameter, do so by editting the appropriate _parameters
! file
!
!
"""



#======================================================================
# class to hold the runtime parameter
#======================================================================
class parameter:

    def __init__(self):

        self.var = ""
        self.type = ""
        self.value = ""

#======================================================================
# getNextline returns the next, non-blank line with comments 
# stripped
#======================================================================
def getNextline(fin):

    line = fin.readline()

    # find position of comment character
    pos = str.find(line, "#")

    # keep reading until you find a non-blank line
    # then strip off the comments
    while((pos == 0) or (str.strip(line) == "") and line):

        line = fin.readline()
        pos = str.find(line, "#")

    line = line[:pos]

    return line

#======================================================================
# getParamIndex returns the index corresponding to a parameter 
# given by var
#======================================================================
def getParamIndex(paramList, var):

    index = -1

    n = 0
    while (n < len(paramList)):

        if (paramList[n].var == var):
            index = n
            break

        n += 1

    return index

#======================================================================
# parseParamFile reads all the parameters in a given file and adds valid
# parametes to the params list
#======================================================================
def parseParamFile(paramsList, paramFile, otherList=None):

    # if otherList is present, we will search through it to avoid 
    # adding duplicate parameters
    if (otherList==None):
        otherList = []

    err = 0

    try: f=open(paramFile, "r")
    except IOError:
        error("file "+str(paramFile)+" does not exist")
    else:
        f.close()

    f = open(paramFile, "r")

    print("write_input_params.py: working on parameter file: "+\
          str(paramFile)+" ...")

    line = getNextline(f)

    # begin parsing the parameter file
    while (line and not err):

        fields = line.split()

        if (not (len(fields) == 3)):
            print(line)
            error("missing one or more fields")
            err = 1
            continue

        # define a parameter object
        currentParam = parameter()

        # fill the parameter object
        currentParam.var   = fields[0]
        currentParam.type  = fields[1]
        currentParam.value = fields[2]

        # is this parameter already in the list
        index = getParamIndex(paramsList, currentParam.var)
        index2 = getParamIndex(otherList, currentParam.var)

        if (index >= 0 or index2 >= 0):
            error("parameter "+str(currentParam.var)+" already defined")
            err = 1

        # store valid parameter
        paramsList.append(currentParam)

        # read next line
        line = getNextline(f)

    return err

#======================================================================
# abort will exit with an error. a file is written such that compilation 
# will fail
#======================================================================
def abort(outfile):

    f = open(outfile, "w")
    f.write("There was an error parsing the parameter files")
    f.close()
    sys.exit(1)

#======================================================================
# write the output file using the template
#======================================================================
def write_io_module(probinTemplate, paramFiles, namelistName, outFile):

    params = []

    print("\nwrite_input_params.py: creating %s" % (outFile))

    #------------------------------------------------------------------
    # read the parameters defined in parameter files
    #------------------------------------------------------------------
    for f in paramFiles:
        err = parseParamFile(params, f)

        if (err):
            abort(outFile)

    #------------------------------------------------------------------
    # open the template
    #------------------------------------------------------------------
    try: ftemplate = open(probinTemplate, "r")
    except IOError:
        error("file "+str(probinTemplate)+" does not exist")
    else:
        ftemplate.close()

    ftemplate = open(probinTemplate, "r")

    # read the lines of the template
    templateLines = []
    line = ftemplate.readline()
    while (line):
        templateLines.append(line)
        line = ftemplate.readline()

    ftemplate.close()

    #------------------------------------------------------------------
    # output the template, inserting the parameter info between the @@...@@
    #------------------------------------------------------------------
    fout = open(outFile, "w")

    fout.write(Header)

    for line in templateLines:

        # find first @@
        index = line.find("@@")

        if (index >= 0):
            # find second @@
            index2 = line.rfind("@@")

            # keyword is what we are filling in
            keyword = line[index+len("@@"):index2]
            indent = index*" "

            if (keyword == "declarations"):

                # declaration statements
                n = 0
                while (n < len(params)):

                    # get variable type
                    type = params[n].type

                    if (type == "real"):
                        fout.write(\
                             "%sreal, save, public :: %s = %s\n" % \
                             (indent, params[n].var, params[n].value))

                    elif (type == "character"):
                        fout.write(\
                            "%scharacter(len=256), save, public :: %s = %s\n"\
                             % (indent, params[n].var, params[n].value))

                    elif (type == "integer"):
                        fout.write(\
                             "%sinteger, save, public :: %s = %s\n" % \
                             (indent, params[n].var, params[n].value))

                    elif (type == "logical"):
                        fout.write(\
                             "%slogical, save, public :: %s = %s\n" % \
                             (indent, params[n].var, params[n].value))

                    else:
                        error("invalid datatype for variable "+\
                               str(params[n].var))

                    n += 1

                if (len(params) == 0):
                    fout.write(\
                         "%sinteger, save, public :: a_dummy_var = 0\n" % \
                        (indent))

            elif (keyword == "namelist"):

                # these variables will be accessible through the namelist
                if (len(params) > 0):
                    n = 0
                    while (n < len(params)):

                        fout.write("%snamelist /%s/ %s\n" % \
                             (indent, namelistName, params[n].var))

                        n += 1
                else:
                    # no runtime parameters were given, but still need to 
                    # define the name of the namelist
                    fout.write("%snamelist /%s/ %s\n" % \
                         (indent, namelistName, "ierr"))

            elif (keyword == "defaults"):

                # default values
                n = 0
                while (n < len(params)):

                    fout.write("%s%s = %s\n" % \
                        (indent, params[n].var, params[n].value))

                    n += 1

            elif (keyword == "commandline"):

                # command line arguments
                n = 0
                while (n < len(params)):

                     fout.write("%scase (\'--%s\')\n" % (indent, params[n].var))
                     fout.write("%s   farg = farg + 1\n" % (indent))

                     if (params[n].type == "character"):
                         fout.write("%s   call get_command_argument(farg, value = %s)\n\n" % (indent, params[n].var))

                     else:
                         fout.write("%s   call get_command_argument(farg, value = fname)\n\n" % (indent))
                         fout.write("%s   read(fname, *) %s\n\n" % \
                           (indent, params[n].var))

                     n += 1

            elif (keyword == "printing"):

                # pretty printing
                fout.write("%s100 format (1x, a32, 1x, \"=\", 1x, a)\n" %
                           (indent))
                fout.write("%s101 format (1x, a32, 1x, \"=\", 1x, i10)\n" %
                           (indent))
                fout.write("%s102 format (1x, a32, 1x, \"=\", 1x, g20.10)\n" %
                           (indent))
                fout.write("%s103 format (1x, a32, 1x, \"=\", 1x, l)\n\n" %
                           (indent))

                n = 0
                while (n < len(params)):

                    type = params[n].type

                    if (type == "real"):
                        fout.write("%swrite (io,102) \"%s\", %s\n" %
                                   (indent, params[n].var, params[n].var) )

                    elif (type == "character"):
                        fout.write("%swrite (io,100) \"%s\", trim(%s)\n" %
                                   (indent, params[n].var, params[n].var) )

                    elif (type == "integer"):
                        fout.write("%swrite (io,101) \"%s\", %s\n" %
                                   (indent, params[n].var, params[n].var))

                    elif (type == "logical"):
                        fout.write("%swrite (io,103) \"%s\", %s\n" %
                                   (indent, params[n].var, params[n].var))

                    else:
                        error("invalid datatype for variable "+params[n].var)

                    n += 1

        else:
            # output the line unchanged
            fout.write(line)

    print()
    fout.close()


#======================================================================
# error
#======================================================================
def error(msg):

    print("\nERROR in write_input_params.py:\n")
    print("\t"+msg+"\n")
    sys.exit(2)

#======================================================================
# main 
#======================================================================
if __name__ == "__main__":

    try:
        opts, args = getopt.getopt(sys.argv[1:], "t:o:n:p:",
                        ["template=", "output=", "namelist=", "paramsfile="])

    except getopt.GetoptError:
        error("invalid calling sequence")

    # defaults
    template = ""   # filename that holds the template
    output = ""     # filename of final fortran code
    namelist = ""   # namelist name e.g. input: namelist /input/ tstop, ...
    paramsfile = "" # list of parameter files to parse

    # sample calling sequence:
    #
    #       ./write_input_params.py -o params.f90 -t ../probin.template \
    #                    -n input -p "file1 file2 file3 file4 file5"
    #

    # parse cmd line args
    for o, a in opts:

        if o in ("-t", "--template"):
            template = a

        elif o in ("-o", "--output"):
            output = a

        elif o in ("-n", "--namelist"):
            namelist = a

        elif o in ("-p", "--paramsfile"):
            paramsfile = a

    # must provide the template file, an output name and a namelist name
    if (template == "" or output == "" or namelist == ""):
        error("invalid calling sequence")

    # split the list of files
    params = paramsfile.split()

    # call main program
    write_io_module(template, params, namelist, output)

